## 什么是状态

**状态就是数据的变化。前端应用的核心问题就是管理状态，管理状态变化之前的通过视图或者其他方式触发的异步过程，管理状态变化之后的联动渲染和联动的逻辑执行**

## 什么是状态管理[​](https://fe.azhubaby.com/React/%E7%94%9F%E6%80%81/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86)

状态管理具体有两层含义：

- 状态变化之前的逻辑，一般是异步的
- 状态变化之后的联动处理，比如渲染视图或执行某段逻辑

比如 React 的 setState 不会马上修改状态，而是异步的批量的执行，把状态做一下合并。

比如 Redux 的 action 在修改全局 state 之前也是要经历中间件的处理的。

这些都是状态变化之前的异步过程的管理，是状态管理的第一层含义

再比如 React setState 修改了状态之后要触发视图的渲染和生命周期函数的执行，hooks 在依赖数组的状态变化之后也会重新执行。（vue 的 data 修改之后会重新渲染视图、执行 computed 和 watch 逻辑）

Redux 修改了全局状态之后要通知组件做渲染或者做其他逻辑的处理，Vuex、Mobx 等都是。

这些是状态变化之后的联动处理的管理，是状态管理的第二层含义

我们知道了什么是状态，什么是状态管理，那前端框架 Vue、React 和全局状态管理的库 Redux、Mobx、Vuex 都是怎么实现状态管理的呢

## React 状态管理方案

### 方案对比

| 框架          | 原理                                                      | 优点                                                                                                                                                                                   | 缺点                                                                                                                                                                                                                                                                       |
| ------------- | --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| hooks context | 基于 react hook，开发者可实现内/外部存储                  | 1. 使用简单<br/> 2. 不需要引用第三方库，体积最小<br/> 3. 支持存储全局状态，但在复杂应用中不推荐<br/> 4. 不依赖 react 上下文，可在组件外调用（外部存储的条件下）                        | 1. context value 发生变化时，所有用到这个 context 的组件都会被重新渲染，基于 content 维护的模块越多，影响范围越大。<br/> 2.依赖 Context Provider 包裹你的应用程序，修改 store 无法在应用最顶层(App.tsx 层级)触发渲染<br/> 3. 受 ui 框架约束(react)<br/> 4. 依赖 hooks 调用 |
| react-redux   | Flux 思想，发布订阅模式，遵从函数式编程，外部存储         | 1. 不依赖 react 上下文，可在组件外调用<br/> 2. 支持存储全局状态<br/> 3. redux 本身是一种通用的状态解决方案                                                                             | 1. 心智模型需要一些时间来理解，特别是当你不熟悉函数式编程的时候<br/> 2. 依赖 Context Provider 包裹你的应用程序，修改 store 无法在应用最顶层(App.tsx 层级)触发渲染<br/> 3.受 ui 框架约束(react)                                                                             |
| mobx          | 观察者模式 + 数据截止，外部存储                           | 1. 使用简单，上手门槛低<br/> 2. 不依赖 react 上下文，可在组件外调用<br/> 3. 支持存储全局状态<br/> 4.通用的状态解决方案                                                                 | 1.可变状态模型，某些情况下可能影响调试<br/> 2. 除了体积相对较大之外，笔者目前未感觉到较为明显的缺点，3.99M                                                                                                                                                                 |
| zustand       | Flux 思想，观察者模式，外部存储                           | 1. 轻量，使用简单，上手门槛低<br/> 2. 不依赖 react 上下文，可在组件外调用<br/> 3. 支持存储全局状态 <br/> 4. 通用的状态解决方案                                                         | 1.框架本身不支持 computed 属性，但可基于 middleware 机制通过少量代码间接实现 computed ，或基于第三方库 zustand-computed 实现<br/>                                                                                                                                          |
| jotai         | 基于 react hook，内部存储                                 | 1. 使用简单<br/> 2. 组件颗粒度较细的情况下，jotai 性能更好<br/> 3.支持存储全局状态                                                                                                     | 1. 依赖 react 上下文， 无法组件外调用，相对而言, zustand 在 react 环境外及全局可以更好地工作<br/> 2.受 ui 框架约束(react)                                                                                                                                                  |
| recoil        | 进阶版 jotai,基于 react hook + provider context，内部存储 | 相对于 jotai 而言，会更重一些，但思想基本不变，拥有一些 jotai 未支持的特性及 api，如：<br/> 1.监听 store 变化<br/> 2. 针对 atom 的操作拥有更多的 api，编程上拥有更多的可能性，更加有趣 | 拥有 jotai 所有的缺点，且相对于 jotai 而言:<br/> 1.使用 recoil 需要 < RecoilRoot > 包裹应用程序<br/> 2. 编写 selector 会复杂一些                                                                                                                                           |

### **业务场景分析**

1. **小型应用 / 简单页面**
   - **推荐状态管理库**：`React hooks` 或 `zustand`
   - **场景**：例如，展示型小型应用，如博客、新闻网站，状态变化不频繁，组件间的交互较少。
   - **原因**：在这种场景下，应用的状态相对简单，使用 React 自带的 `useState` 和 `useContext` 就可以满足需求，避免引入过于复杂的状态管理库。
2. **复杂的动态数据应用**
   - **推荐状态管理库**：`Redux` 或 `Mobx`
   - **场景**：如在线编辑器、社交平台，多个组件之间需要频繁地共享数据和触发更新。
   - **原因**：这些应用中通常需要跨多个组件共享状态，并且涉及到复杂的状态变更和调试需求。`Redux` 通过严格的 Action/Reducer 模式适合复杂逻辑，而 `Mobx` 提供了更加灵活的响应式编程，适合较为复杂的数据流和响应式变化。
3. **性能要求较高的应用**
   - **推荐状态管理库**：`Jotai` 或 `zustand`
   - **场景**：如大规模数据表格、实时数据展示等。
   - **原因**：`Jotai` 和 `zustand` 提供了较高的性能优化，能够精细地控制状态的更新和组件的重新渲染，适合需要高效渲染性能的应用。
4. **需要复杂的派生状态和异步处理**
   - **推荐状态管理库**：`Recoil`
   - **场景**：如实时协作工具、复杂的表单，或需要根据多个不同数据源计算出的状态。
   - **原因**：`Recoil` 提供了更强大的 `selector` 功能，适合管理复杂的数据流和派生状态，它允许你方便地组合和依赖多个原子状态。
5. **轻量应用 / 原子化状态管理**
   - **推荐状态管理库**：`Jotai` 或 `zustand`
   - **场景**：如个人小工具、简单的计数器应用等。
   - **原因**：这类应用通常对状态管理的要求不高，`Jotai` 和 `zustand` 由于其轻量级的特点，非常适合用于开发这些小型应用，避免过度引入框架。
